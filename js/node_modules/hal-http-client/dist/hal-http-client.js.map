{"version":3,"sources":["../hal-http-client.js"],"names":["create","removeHalKeys","canFollow","firstRelationHref","selfLink","DEFAULT_SAFE_HEADERS","DEFAULT_UNSAFE_HEADERS","DEFAULT_PATCH_HEADERS","STATUS_NOREL","optionalOptions","getPromiseCache","globalOptions","queueUnsafeRequests","headers","fetchInit","middlewares","on","responseTransformer","response","logError","console","error","msg","logDebug","debug","globalOnHandlers","expandHandlers","api","get","head","put","post","patch","del","delete","follow","followAll","thenFollow","thenFollowAll","urlOrHalRepresentation","url","extractUrl","options","cacheKey","createCacheKey","createHeaders","promise","doFetch","then","removeFromCache","extendResponsePromise","body","unsafeRequest","halRepresentation","relation","vars","method","undefined","Promise","resolve","reject","path","embedded","_embedded","all","Array","isArray","map","status","text","JSON","stringify","data","linkOrLinks","_links","links","allSettled","href","expandPossibleVars","link","request","info","requestOptions","requestFunction","toLowerCase","indexOf","toUpperCase","representation","continuationPromise","optionalBody","next","createCallStatusHandler","handlers","statusHandlers","__unhandledOn","length","every","_","handler","findBestMatchingStatusHandler","config","message","__bodyPromise","result","parseJson","json","parse","e","templated","template","expand","globalHandlers","statusStr","localHandlers","statusKeys","substr","i","len","tmp","Object","keys","forEach","value","key","keyParts","split","keyPart","promises","finished","waitingFor","failed","index","doneCallback","rejected","Error","sort","reduce","acc","bodyObject","lcHeaders","init","createInit","applyRequestMiddlewares","fetch","applyResponseMiddlewares","requestInfo","combine","requestInfoPromise","nextMiddleware","responseInfo","responsePromise","reverse","localInit","localHeaders","defaultHeaders","copy","obj","thePath","optionalDefault","pathArr","node","shift","hasOwnProperty"],"mappings":"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","file":"hal-http-client.js","sourcesContent":["/**\n * Copyright 2017 aixigo AG\n * Released under the MIT license.\n * http://laxarjs.org/license\n */\n/**\n * A _status code driven_ JSON [HAL](http://stateless.co/hal_specification.html) HTTP client based on the\n * [fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).\n *\n * @module hal-http-client\n */\n\nimport template from 'url-template';\n\n/**\n * Default headers used with safe http methods.\n *\n * @type {Object}\n * @private\n */\nconst DEFAULT_SAFE_HEADERS = {\n   'accept': 'application/hal+json, application/json;q=0.8'\n};\n\n/**\n * Default headers used with unsafe http methods.\n *\n * @type {Object}\n * @private\n */\nconst DEFAULT_UNSAFE_HEADERS = {\n   ...DEFAULT_SAFE_HEADERS,\n   'content-type': 'application/json'\n};\n\n/**\n * Default headers used with the PATCH http methods.\n *\n * @type {Object}\n * @private\n */\nconst DEFAULT_PATCH_HEADERS = {\n   ...DEFAULT_SAFE_HEADERS,\n   'content-type': 'application/json-patch+json'\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Virtual status code `'norel'` for a missing relation to use as key in the `on`-handlers map.\n *\n * @name STATUS_NOREL\n * @type {String}\n */\nexport const STATUS_NOREL = 'norel';\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Creates a new http client for usage with a RESTful backend supporting the content type\n * `application/hal+json` (https://tools.ietf.org/html/draft-kelly-json-hal-06).\n *\n * Example:\n * ```js\n * const hal = create( {\n *    on: {\n *       'xxx'( data, response ) {\n *          console.log( 'I\\'ll handle everything not handled locally' );\n *       }\n *    }\n * } );\n *\n * hal.get( 'http://host/someResource' )\n *    .on( {\n *       '2xx'( data, response ) {\n *          console.log( 'Everything looks fine: ', data );\n *          return hal.follow( data, 'some-relation' );\n *       },\n *       '4xx|5xx'( data, response ) {\n *          console.log( 'Server or client failed. Who knows? The status!', response.status );\n *       }\n *    } )\n *    // handle the response from following 'some-relation'\n *    .on( {\n *       '200'( data, response ) {\n *          console.log( 'I got this: ', data );\n *       },\n *       'norel'() {\n *           console.log( 'Oh no, seems \"some-relation\" is missing in the representation' );\n *       }\n *    } );\n * ```\n *\n * See {@link #ResponsePromise} for further information on the `on` function.\n *\n * @param {Object} [optionalOptions]\n *    map of global configuration to use for the HAL client\n * @param {Boolean} [optionalOptions.queueUnsafeRequests]\n *    if `true` an unsafe request (DELETE, PATCH, POST and PUT) has to be finished before the next is started.\n *    Default is `false`\n * @param {Object} [optionalOptions.headers]\n *    global headers to send along with every request\n * @param {Array<{request: Function, response: Function}>} [optionalOptions.middlewares]\n *    optional array of middlewares to preprocess requests and to postprocess responses.\n *    Each middleware is an object with a `request` and a `response` method.\n *\n *    The `request` method is called everytime that a request is made.\n *    It is invoked with a single argument of the form `{ url: String, init: Object }`.\n *    The `url` is the target URL and `init` contains the fetch-init options as they would be passed to\n *    fetch if no middleware was present.\n *    The method must return an object of the same shape, or a Promise for such an object.\n *\n *    The `response` method is called everytime a response is received.\n *    It is invoked with single argument of the form `{ response: Response, url: String, init: Object }`.\n *    The `response` is the response from the server, and `url` and `init` are the URL and init options that\n *    were passed to `fetch` to obtain that response.\n *    The method must return an object of the same shape, or a Promise for such an object.\n *\n *    When multiple middlewares are used, they are run left-to-right (requests) and right-to-left (responses).\n *    The result (of the promise) generated by each middleware is passed to the next middleware.\n *    The result of the rightmost middleware's `request` method is passed to the fetch-API of the browser.\n *    The result of the leftmost middleware's `response` method is used for further response processing (e.g.\n *    calling on-handlers).\n *\n *    Note that you can freely transform requests and responses, or even make intermediate requests.\n *    In request middleware, you could e.g. completely rewrite the URL.\n *    In response middleware, you are not obliged to return the same response: you could make a\n *    different fetch-request instead and return the response of that request.\n *\n * @param {Object} [optionalOptions.fetchInit]\n *    additional init options for `fetch` to be used with every request. The keys `headers`, `body` and\n *    `method` are ignored from this option, since they are either parameters on their own or implemented as\n *    specific function.\n * @param {Object} [optionalOptions.on]\n *    global `on` handlers to use as fallback if no matching handler was found in an `on` call\n * @param {Function} [optionalOptions.responseTransformer]\n *    a function that is called for every response and must return an optionally transformed version of\n *    that response. This can e.g. be used for URL rewriting of proxied requests during development. This\n *    should not be used in production for transformation of actual data\n * @param {Function} [optionalOptions.logError]\n *    a function to log error messages to. By default `console.error` is used\n * @param {Function} [optionalOptions.logDebug]\n *    a function to log debug / development messages to. By default `console.debug` is used\n *\n * @return {HalHttpClient}\n *    a new HAL client instance\n */\nexport function create( optionalOptions = {} ) {\n\n   const getPromiseCache = {};\n   const globalOptions = {\n      queueUnsafeRequests: false,\n      headers: {},\n      fetchInit: {},\n      middlewares: [],\n      on: {},\n      responseTransformer: response => response,\n      logError: msg => { console.error( msg ); }, // eslint-disable-line no-console\n      logDebug: msg => { console.debug( msg ); }, // eslint-disable-line no-console\n      ...optionalOptions\n   };\n   const { logError, logDebug } = globalOptions;\n   const globalOnHandlers = expandHandlers( globalOptions.on );\n\n   /**\n    * @constructor\n    * @name HalHttpClient\n    */\n   const api = {\n      get,\n      head,\n      put,\n      post,\n      patch,\n      del,\n      delete: del,\n      follow,\n      followAll,\n      thenFollow,\n      thenFollowAll\n   };\n\n   ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n   /**\n    * Makes a GET request for the given URL or HAL representation. In case a HAL representation is given,\n    * the `self` relation in the `_links` map is used to derive the URL for the request.\n    *\n    * @param {String|Object} urlOrHalRepresentation\n    *    a URL or a HAL representation to make the request for\n    * @param {Object} [optionalOptions]\n    *    configuration to use for the request\n    * @param {Object} [optionalOptions.headers]\n    *    headers to send along with the request. By default,\n    *    `Accept: application/hal+json, application/json;q=0.8` is added to the headers\n    * @param {Object} [optionalOptions.fetchInit]\n    *    additional init options for `fetch` to be used for this request only. The keys `headers`, `body` and\n    *    `method` are ignored from this option, since they are either parameters on their own or implemented\n    *    as specific function.\n    *\n    * @return {ResponsePromise}\n    *    an extended promise for the response\n    *\n    * @memberof HalHttpClient\n    */\n   function get( urlOrHalRepresentation, optionalOptions ) {\n      const url = extractUrl( urlOrHalRepresentation );\n      const options = {\n         headers: {},\n         fetchInit: {},\n         ...optionalOptions\n      };\n\n      const cacheKey = createCacheKey( url, createHeaders( 'GET', options.headers ) );\n      if( cacheKey in getPromiseCache ) {\n         return getPromiseCache[ cacheKey ];\n      }\n\n      const promise = doFetch( url, options )\n         .then( response => globalOptions.responseTransformer( response ) );\n\n      const removeFromCache = () => { delete getPromiseCache[ cacheKey ]; };\n      promise.then( removeFromCache, removeFromCache );\n\n      getPromiseCache[ cacheKey ] = extendResponsePromise( promise );\n      return getPromiseCache[ cacheKey ];\n   }\n\n   ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n   /**\n    * Makes a HEAD request for the given URL or HAL representation.\n    * In case a HAL representation is given, the `self` relation in the `_links` map is used to derive the URL\n    * for the request.\n    *\n    * @param {String|Object} urlOrHalRepresentation\n    *    an URL or a HAL representation to make the request for\n    * @param {Object} [optionalOptions]\n    *    configuration to use for the request\n    * @param {Object} [optionalOptions.headers]\n    *    headers to send along with the request. By default no headers are set\n    * @param {Object} [optionalOptions.fetchInit]\n    *    additional init options for `fetch` to be used for this request only. The keys `headers`, `body` and\n    *    `method` are ignored from this option, since they are either parameters on their own or implemented\n    *    as specific function.\n    *\n    * @return {ResponsePromise}\n    *    an extended promise for the response\n    *\n    * @memberof HalHttpClient\n    */\n   function head( urlOrHalRepresentation, optionalOptions ) {\n      const url = extractUrl( urlOrHalRepresentation );\n      const options = {\n         headers: {},\n         fetchInit: {},\n         ...optionalOptions\n      };\n\n      return extendResponsePromise( doFetch( url, options, 'HEAD' ) );\n   }\n\n   ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n   /**\n    * Makes a PUT request for the given URL or HAL representation. In case a HAL representation is given,\n    * the `self` relation in the `_links` map is used to derive the URL for the request.\n    *\n    * @param {String|Object} urlOrHalRepresentation\n    *    an URL or a HAL representation to make the request for\n    * @param {Object} body\n    *    JSON serializable body to send\n    * @param {Object} [optionalOptions]\n    *    configuration to use for the request\n    * @param {Object} [optionalOptions.headers]\n    *    headers to send along with the request. By default `Accept: application/hal+json` and\n    *    `Content-Type: application/json` are added to the headers\n    * @param {Object} [optionalOptions.fetchInit]\n    *    additional init options for `fetch` to be used for this request only. The keys `headers`, `body` and\n    *    `method` are ignored from this option, since they are either parameters on their own or implemented\n    *    as specific function.\n    *\n    * @return {ResponsePromise}\n    *    an extended promise for the response\n    *\n    * @memberof HalHttpClient\n    */\n   function put( urlOrHalRepresentation, body, optionalOptions ) {\n      return unsafeRequest( 'PUT', urlOrHalRepresentation, optionalOptions, body );\n   }\n\n   ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n   /**\n    * Makes a POST request for the given URL or HAL representation. In case a HAL representation is given,\n    * the `self` relation in the `_links` map is used to derive the URL for the request.\n    *\n    * @param {String|Object} urlOrHalRepresentation\n    *    an URL or a HAL representation to make the request for\n    * @param {Object} body\n    *    JSON serializable body to send\n    * @param {Object} [optionalOptions]\n    *    configuration to use for the request\n    * @param {Object} [optionalOptions.headers]\n    *    headers to send along with the request. By default,\n    *    `Accept: application/hal+json, application/json;q=0.8` and\n    *    `Content-Type: application/json` are added to the headers\n    * @param {Object} [optionalOptions.fetchInit]\n    *    additional init options for `fetch` to be used for this request only. The keys `headers`, `body` and\n    *    `method` are ignored from this option, since they are either parameters on their own or implemented\n    *    as specific function.\n    *\n    * @return {ResponsePromise}\n    *    an extended promise for the response\n    *\n    * @memberof HalHttpClient\n    */\n   function post( urlOrHalRepresentation, body, optionalOptions ) {\n      return unsafeRequest( 'POST', urlOrHalRepresentation, optionalOptions, body );\n   }\n\n   ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n   /**\n    * Makes a PATCH request for the given URL or HAL representation. In case a HAL representation is given,\n    * the `self` relation in the `_links` map is used to derive the URL for the request.\n    *\n    * @param {String|Object} urlOrHalRepresentation\n    *    a URL or a HAL representation to make the request for\n    * @param {Object} body\n    *    body in JSON Patch notation (http://tools.ietf.org/html/rfc6902)\n    * @param {Object} [optionalOptions]\n    *    configuration to use for the request\n    * @param {Object} [optionalOptions.headers]\n    *    headers to send along with the request. By default,\n    *    `Accept: application/hal+json, application/json;q=0.8` and\n    *    `Content-Type: application/json-patch+json` are added to the headers\n    * @param {Object} [optionalOptions.fetchInit]\n    *    additional init options for `fetch` to be used for this request only. The keys `headers`, `body` and\n    *    `method` are ignored from this option, since they are either parameters on their own or implemented\n    *    as specific function.\n    *\n    * @return {ResponsePromise}\n    *    an extended promise for the response\n    *\n    * @memberof HalHttpClient\n    */\n   function patch( urlOrHalRepresentation, body, optionalOptions ) {\n      return unsafeRequest( 'PATCH', urlOrHalRepresentation, optionalOptions, body );\n   }\n\n   ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n   /**\n    * Makes a DELETE request for the given URL or HAL representation. In case a HAL representation is given,\n    * the `self` relation in the `_links` map is used to derive the URL for the request.\n    *\n    * @param {String|Object} urlOrHalRepresentation\n    *    an URL or a HAL representation to make the request for\n    * @param {Object} [body]\n    *    JSON serializable body to send. If you want to use options, but have no `body`, use `undefined` as\n    *    value for `body`\n    * @param {Object} [optionalOptions]\n    *    configuration to use for the request\n    * @param {Object} [optionalOptions.headers]\n    *    headers to send along with the request. By default\n    *    `Accept: application/hal+json, application/json;q=0.8` and\n    *    `Content-Type: application/json` are added to the headers\n    * @param {Object} [optionalOptions.fetchInit]\n    *    additional init options for `fetch` to be used for this request only. The keys `headers`, `body` and\n    *    `method` are ignored from this option, since they are either parameters on their own or implemented\n    *    as specific function.\n    *\n    * @return {ResponsePromise}\n    *    an extended promise for the response\n    *\n    * @memberof HalHttpClient\n    */\n   function del( urlOrHalRepresentation, body, optionalOptions ) {\n      return unsafeRequest( 'DELETE', urlOrHalRepresentation, optionalOptions, body );\n   }\n\n   ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n   /**\n    * Follows one or more resources of a relation within a given HAL representation. First it is checked if\n    * a representation for the relation is already embedded and in case it exists, this will be the result.\n    * If that isn't the case, the `_links` property is searched for a URL of that relation and if found, a\n    * GET request for this URL is performed. If the relation could not be found in the given representation\n    * the resulting promise is rejected.\n    *\n    * If there are multiple links or embedded resources, by default only the first one will be requested and\n    * its response passed to the consumers of the promise. In case the `followAll` option is set to `true`,\n    * all found embedded representations are returned or all relations found in the `_links` property are\n    * requested resp.. The resulting promise will then be resolved with an array of responses instead of a\n    * single response. As there might be different status codes for the responses, a specific `on` handler is\n    * only called if all status codes yield the same value. In any other case *only* the handler for `xxx` is\n    * called. This can be prevented, if a list resource always embeds the representations of its items.\n    *\n    * @param {Object} halRepresentation\n    *    the representation whose relation should be followed\n    * @param {String} relation\n    *    the relation to follow\n    * @param {Object} [optionalOptions]\n    *    configuration to use for the request\n    * @param {Object} [optionalOptions.method]\n    *    method to use for the request(s). If not `GET`, embedded representations will be ignored. Default is\n    *    `GET`\n    * @param {Object} [optionalOptions.body]\n    *    JSON serializable body to send\n    * @param {Object} [optionalOptions.headers]\n    *    headers to send along with the request. The same default headers as for `get()` are used\n    * @param {Object} [optionalOptions.fetchInit]\n    *    additional init options for `fetch` to be used for this request only. The keys `headers`, `body` and\n    *    `method` are ignored from this option, since they are either parameters on their own or implemented\n    *    as specific function.\n    * @param {Boolean} [optionalOptions.followAll]\n    *    if `true`, follows all entities found for that relation. Default is `false`\n    * @param {Object} [optionalOptions.vars]\n    *    map of variables to replace in templated URLs\n    *\n    * @return {ResponsePromise}\n    *    an extended promise for the response\n    *\n    * @memberof HalHttpClient\n    */\n   function follow( halRepresentation, relation, optionalOptions = {} ) {\n      const options = {\n         followAll: false,\n         headers: {},\n         fetchInit: {},\n         vars: {},\n         method: 'GET',\n         body: undefined,\n         ...optionalOptions\n      };\n\n      return extendResponsePromise( new Promise( ( resolve, reject ) => {\n         if( options.method === 'GET' && path( halRepresentation, `_embedded.${relation}` ) ) {\n            const embedded = halRepresentation._embedded[ relation ];\n            if( options.followAll ) {\n               const all = Array.isArray( embedded ) ? embedded : [ embedded ];\n               resolve( all.map( data => {\n                  return {\n                     status: 200,\n                     headers: {},\n                     text: () => Promise.resolve( JSON.stringify( data ) )\n                  };\n               } ) );\n            }\n            else {\n               const data = Array.isArray( embedded ) ? embedded[ 0 ] : embedded;\n               resolve( {\n                  status: 200,\n                  headers: {},\n                  text: () => Promise.resolve( JSON.stringify( data ) )\n               } );\n            }\n         }\n         else if( path( halRepresentation, `_links.${relation}` ) ) {\n            const linkOrLinks = halRepresentation._links[ relation ];\n            if( options.followAll ) {\n               const links = Array.isArray( linkOrLinks ) ? linkOrLinks : [ linkOrLinks ];\n               allSettled( links.map( link => {\n                  const href = expandPossibleVars( link, options.vars );\n                  return request( href );\n               } ) ).then( resolve, reject );\n            }\n            else {\n               const link = Array.isArray( linkOrLinks ) ? linkOrLinks[ 0 ] : linkOrLinks;\n               const href = expandPossibleVars( link, options.vars );\n               request( href ).then( resolve, reject );\n            }\n         }\n         else {\n            resolve( {\n               status: STATUS_NOREL,\n               info: { halRepresentation, relation },\n               headers: {},\n               text: () => Promise.resolve( JSON.stringify( null ) )\n            } );\n         }\n      } ) );\n\n      function request( href ) {\n         const requestOptions = { headers: options.headers, fetchInit: options.fetchInit };\n         const requestFunction = api[ options.method.toLowerCase() ];\n         if( [ 'DELETE', 'PATCH', 'POST', 'PUT' ].indexOf( options.method.toUpperCase() ) !== -1 ) {\n            return requestFunction( href, options.body, requestOptions );\n         }\n         return requestFunction( href, requestOptions );\n      }\n   }\n\n   ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n   /**\n    * A shortcut function for {@link #HalHttpClient.follow()} called with `followAll` yielding `true`:\n    * `follow( halRepresentation, relation, { followAll: true } )`.\n    *\n    * @param {Object} halRepresentation\n    *    the representation whose relation should be followed\n    * @param {String} relation\n    *    the relation to follow\n    * @param {Object} [optionalOptions]\n    *    configuration to use for the request\n    * @param {Object} [optionalOptions.method]\n    *    method to use for the request(s). If not `GET`, embedded representations will be ignored. Default is\n    *    `GET`\n    * @param {Object} [optionalOptions.body]\n    *    JSON serializable body to send\n    * @param {Object} [optionalOptions.headers]\n    *    headers to send along with the request. The same default headers as for `get()` are used\n    * @param {Object} [optionalOptions.fetchInit]\n    *    additional init options for `fetch` to be used for this request only. The keys `headers`, `body` and\n    *    `method` are ignored from this option, since they are either parameters on their own or implemented\n    *    as specific function.\n    * @param {Object} [optionalOptions.vars]\n    *    map of variables to replace in templated URLs\n    *\n    * @return {ResponsePromise}\n    *    an extended promise for the response\n    *\n    * @memberof HalHttpClient\n    */\n   function followAll( halRepresentation, relation, optionalOptions = {} ) {\n      const options = optionalOptions;\n      options.followAll = true;\n      return follow( halRepresentation, relation, options );\n   }\n\n   ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n   /**\n    * Helper factory for `follow()` function calls. The returned function only expects a HAL representation as\n    * argument, and calls {@link #HalHttpClient.follow()} using that representation as first argument.\n    * The purpose of this method is the use within chained `follow()` calls, especially in `on` handlers.\n    *\n    * Example:\n    * ```js\n    * halClient.get( 'http://host/office' )\n    *    .on( { '200': halClient.thenFollow( 'desk' ) } )\n    *    .on( { '200': halClient.thenFollow( 'computer' ) } )\n    *    .on( { '200': halClient.thenFollow( 'keyboard' ) } );\n    * // ...\n    * ```\n    * Assuming every response yields a status of `200`, first a representation of an office resource is\n    * fetched, then the `desk` relation is followed, then within the resulting representation the `computer`\n    * relation is followed and finally within that representation the `keyboard` relation is followed.\n    *\n    * Note that this method cannot be used in an `on` handler after a `followAll` request, as there will be\n    * an array of objects instead of only one object.\n    *\n    * @param {String} relation\n    *    the relation to follow\n    * @param {Object} [optionalOptions]\n    *    configuration to use for the request\n    * @param {Object} [optionalOptions.method]\n    *    method to use for the request(s). If not `GET`, embedded representations will be ignored. Default is\n    *    `GET`\n    * @param {Object} [optionalOptions.body]\n    *    JSON serializable body to send\n    * @param {Object} [optionalOptions.headers]\n    *    headers to send along with the request. The same default headers as for `get()` are used\n    * @param {Object} [optionalOptions.fetchInit]\n    *    additional init options for `fetch` to be used for this request only. The keys `headers`, `body` and\n    *    `method` are ignored from this option, since they are either parameters on their own or implemented\n    *    as specific function.\n    * @param {Boolean} [optionalOptions.followAll]\n    *    if `true`, follows all entities found for that relation. Default is `false`\n    *\n    * @return {Function}\n    *    a function calling `follow` on the response it receives\n    *\n    * @memberof HalHttpClient\n    */\n   function thenFollow( relation, optionalOptions ) {\n      return function( representation ) {\n         return follow( representation, relation, optionalOptions );\n      };\n   }\n\n   ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n   /**\n    * A shortcut function for {@link #HalHttpClient.thenFollow()} called with `followAll` yielding `true`:\n    * `thenFollow( relation, { followAll: true } )`.\n    *\n    * @param {String} relation\n    *    the relation to follow\n    * @param {Object} [optionalOptions]\n    *    configuration to use for the request\n    * @param {Object} [optionalOptions.method]\n    *    method to use for the request(s). If not `GET`, embedded representations will be ignored. Default is\n    *    `GET`\n    * @param {Object} [optionalOptions.body]\n    *    JSON serializable body to send\n    * @param {Object} [optionalOptions.headers]\n    *    headers to send along with the request. The same default headers as for `get()` are used\n    * @param {Object} [optionalOptions.fetchInit]\n    *    additional init options for `fetch` to be used for this request only. The keys `headers`, `body` and\n    *    `method` are ignored from this option, since they are either parameters on their own or implemented\n    *    as specific function.\n    *\n    * @return {Function}\n    *    a function calling `followAll` on the response it receives\n    *\n    * @memberof HalHttpClient\n    */\n   function thenFollowAll( relation, optionalOptions ) {\n      return function( representation ) {\n         return followAll( representation, relation, optionalOptions );\n      };\n   }\n\n   ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n   let continuationPromise;\n   function unsafeRequest( method, urlOrHalRepresentation, optionalOptions = {}, optionalBody = {} ) {\n      const url = extractUrl( urlOrHalRepresentation );\n      const options = {\n         headers: {},\n         fetchInit: {},\n         ...optionalOptions\n      };\n\n      if( globalOptions.queueUnsafeRequests === true ) {\n         continuationPromise = continuationPromise ? continuationPromise.then( next, next ) : next();\n         return extendResponsePromise( continuationPromise );\n      }\n\n      return extendResponsePromise( next() );\n\n      ////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n      function next() {\n         return doFetch( url, options, method, optionalBody ).then(\n            response => globalOptions.responseTransformer( response ),\n            response => Promise.reject( globalOptions.responseTransformer( response ) )\n         );\n      }\n   }\n\n   ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n   function extendResponsePromise( promise ) {\n\n      /**\n       * A simple extension of a normal\n       * [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).\n       * Its purpose is to add some convenience when following relations of a resource. Using the standard\n       * Promise API is still possible.\n       *\n       * @name ResponsePromise\n       * @constructor\n       * @extends Promise\n       */\n\n      /**\n       * A function to register handlers for the possible\n       * [HTTP status codes](https://tools.ietf.org/html/rfc7231#page-47) returned by the API. This is the\n       * actual heart of this library.\n       *\n       * This function has to be called with a map of status codes to functions responsible for handling the\n       * response that was given for an actual status code. It is possible to group status codes using the\n       * same handler for their codes. And lastly wildcards are possible to be able to treat a specific class\n       * of status codes conveniently the same way.\n       *\n       * Let's have a look at an example:\n       * ```js\n       * const handler1 = ( result, response ) => {};\n       * const handler2 = ( result, response ) => {};\n       * const handler3 = ( result, response ) => {};\n       * const handler4 = ( result, response ) => {};\n       *\n       * hal.get( 'my-resource' )\n       *    .on( {\n       *       '200': handler1,\n       *       '201|202|204': handler2,\n       *       '5xx': handler3\n       *    } );\n       * ```\n       * Here `handler1` will only be called for status code _200_, `handler2` for the given status codes\n       * _201_, _202_ and _204_, and `handler3` will be called for any type of server error. A final catch all\n       * handler could have also been added simply using a full wildcard string _xxx_. Any code that is not\n       * handled by this map of handlers is forwarded to the global handlers map (see {@link create()}). In\n       * case there is no handler there either, this will be logged and the next returned promise will be\n       * rejected.\n       *\n       * Each handler receives to arguments: First, the body of the response (already parsed from a JSON\n       * string into a JavaScript object). The second argument is the plain response object as returned by\n       * the underlying `fetch` API. In case the entries of a list resource were fetched the arguments will\n       * be arrays, carrying the body and response objects of all list items.\n       *\n       * If the response cannot be parsed into valid JSON (for example, if the server returns an HTML error\n       * page which may often happen in case of a `4xx` or `5xx`), the status code will be kept, but the\n       * `result` object is set to `null`. In this case, interested handlers can still inspect the complete\n       * response for details.\n       *\n       * Handlers can then further follow relations of the provided body object by using the convenience\n       * methods {@link #HalHttpClient.follow()} or {@link #HalHttpClient.followAll()}, and returning the\n       * resulting `ResponsePromise` for typical Promise-like chaining. If a handler really does nothing apart\n       * from following a relation of the HAL response, a generic handler can even be created by using\n       * {@link #HalHttpClient.thenFollow()} or {@link #HalHttpClient.thenFollowAll()}. In addition to the\n       * http status codes and _xxx_ a \"virtual\" code of `'norel'` can be used to handle the case, where a\n       * relation is missing in a response.\n       *\n       * If a handler returns nothing or `null`, and by that indicating an empty response, subsequent handlers\n       * will never be called.\n       *\n       * *Special cases*\n       *\n       * - _An empty list resource_: This will be returned with overall status code _200_.\n       * - _Different status codes for the list items_: This will only trigger the _xxx_ handler.\n       * - _The relation to follow doesn't exist_: The _norel_ handler will be called\n       *\n       *\n       * @param {Object} handlers\n       *    the map of handlers as described above\n       *\n       * @return {ResponsePromise}\n       *    an extended promise for the result of the handler that was called\n       *\n       * @memberof ResponsePromise\n       */\n      promise.on = handlers => extendResponsePromise( promise.then( createCallStatusHandler( handlers ) ) );\n\n      return promise;\n\n      ////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n      function createCallStatusHandler( statusHandlers ) {\n         return response => {\n            if( !response ) {\n               return null;\n            }\n\n            if( response.__unhandledOn ) {\n               return Promise.reject( response );\n            }\n\n            let status = response.status || 'xxx';\n            if( !( 'status' in response ) && Array.isArray( response ) ) {\n               if( response.length ) {\n                  status = response[ 0 ].status;\n                  if( !response.every( _ => _.status === status ) ) {\n                     status = 'xxx';\n                  }\n               }\n               else {\n                  // This is the case, when we tried to follow a list of embedded resources, but there\n                  // were no entries. For list resources it hence is totally valid to be empty. If\n                  // emptiness is a problem, that has to be handled later on by functional code.\n                  status = 200;\n               }\n            }\n\n            const handler = findBestMatchingStatusHandler( status, statusHandlers, globalOnHandlers );\n            if( !handler ) {\n               if( status === STATUS_NOREL ) {\n                  const { relation, halRepresentation } = response.info;\n                  logError( `Relation \"${relation}\" is missing and no ${STATUS_NOREL} handler was found.` );\n                  logDebug( `Offending representation: ${JSON.stringify( halRepresentation )}` );\n               }\n               else if( response.config && response.config.url ) {\n                  logDebug(\n                     `Unhandled http status \"${status}\" of response for uri \"${response.config.url}\".`\n                  );\n               }\n               else if( response.message && response.representation ) {\n                  logError( `An error occured: ${response.message}.` );\n                  logError( `Representation: ${JSON.stringify( response.representation )}.` );\n               }\n               else {\n                  logError(\n                     `Unhandled http status \"${status}\" of response \"${JSON.stringify( response )}\".`\n                  );\n               }\n\n               response.__unhandledOn = true;\n               return Promise.reject( response );\n            }\n            if( !response.__bodyPromise ) {\n               if( Array.isArray( response ) ) {\n                  response.__bodyPromise = Promise.all( response.map( response => response.text() ) );\n               }\n               else {\n                  response.__bodyPromise = response.text();\n               }\n            }\n\n            return response.__bodyPromise\n               .then( body => {\n                  let result = null;\n                  if( Array.isArray( body ) ) {\n                     result = body.map( _ => _ ? parseJson( _ ) : null );\n                  }\n                  else if( body ) {\n                     result = parseJson( body );\n                  }\n                  return handler( result, response );\n               } );\n\n            function parseJson( json ) {\n               try {\n                  return JSON.parse( json );\n               }\n               catch( e ) {\n                  // e.g. because an HTML error page was served\n                  return null;\n               }\n            }\n         };\n      }\n   }\n\n   ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n   function expandPossibleVars( link, vars ) {\n      if( !link.templated ) {\n         return link.href;\n      }\n\n      return template.parse( link.href ).expand( vars );\n   }\n\n   ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n   function findBestMatchingStatusHandler( status, handlers, globalHandlers ) {\n      const statusStr = `${status}`;\n      const localHandlers = expandHandlers( handlers );\n      const statusKeys = status === STATUS_NOREL ?\n         [ STATUS_NOREL ] :\n         [ statusStr, `${statusStr.substr( 0, 2 )}x`, `${statusStr[ 0 ]}xx`, 'xxx' ];\n\n      for( let i = 0, len = statusKeys.length; i < len; ++i ) {\n         if( statusKeys[ i ] in localHandlers ) {\n            return localHandlers[ statusKeys[ i ] ];\n         }\n      }\n\n      for( let i = 0, len = statusKeys.length; i < len; ++i ) {\n         if( statusKeys[ i ] in globalHandlers ) {\n            return globalHandlers[ statusKeys[ i ] ];\n         }\n      }\n\n      return null;\n   }\n\n   ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n   function expandHandlers( handlers ) {\n      const tmp = {};\n\n      Object.keys( handlers ).forEach( key => {\n         const value = handlers[ key ];\n         const keyParts = key.split( '|' );\n         keyParts.forEach( keyPart => {\n            tmp[ keyPart ] = value;\n         } );\n      } );\n\n      return tmp;\n   }\n\n   ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n   /*\n    * Similar to `Promise.all` but waits for all promises to be fulfilled, no matter if some get rejected or\n    * not.\n    * The resulting promise is rejected if at least one input promise is rejected and resolved otherwise.\n    * The argument array consists of all promise values, thus inspection by the application is necessary to\n    * sort out the rejections.\n    *\n    * @private\n    */\n   function allSettled( promises ) {\n      return new Promise( ( resolve, reject ) => {\n         const finished = [];\n         let waitingFor = promises.length;\n         let failed = false;\n\n         promises.forEach( ( promise, index ) => {\n            promise.then( doneCallback( false ), doneCallback( true ) );\n\n            function doneCallback( rejected ) {\n               return function( result ) {\n                  failed = rejected || failed;\n                  finished[ index ] = result;\n                  if( --waitingFor === 0 ) {\n                     if( failed ) {\n                        reject( finished );\n                     }\n                     else {\n                        resolve( finished );\n                     }\n                  }\n               };\n            }\n         } );\n      } );\n   }\n\n   ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n   function extractUrl( urlOrHalRepresentation ) {\n      const url = typeof urlOrHalRepresentation === 'string' ?\n         urlOrHalRepresentation : path( urlOrHalRepresentation, '_links.self.href', null );\n\n      if( !url ) {\n         logError( 'Tried to make a request without valid url. Instead got [0:%o].', urlOrHalRepresentation );\n         throw new Error( 'Tried to make a request without valid url' );\n      }\n\n      return url;\n   }\n\n   ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n   function createCacheKey( url, headers ) {\n      return Object.keys( headers ).sort().reduce(\n         ( acc, key, index ) => `${acc}${index ? '_' : ''}${key}=${headers[ key ]}`,\n         `${url}@`\n      );\n   }\n\n   ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n   function doFetch( url, options, method = 'GET', bodyObject = undefined ) {\n      const headers = createHeaders( method, options.headers );\n      const lcHeaders = {};\n      Object.keys( headers ).forEach( key => {\n         lcHeaders[ key.toLowerCase() ] = headers[ key ];\n      } );\n\n      const init = createInit( options.fetchInit, method, lcHeaders, bodyObject );\n      const result = applyRequestMiddlewares( { url, init } )\n         .then( ({ url, init }) => fetch( url, init )\n            .then( response => applyResponseMiddlewares( { response, url, init } ) )\n            .then( ({ response }) => response ) );\n      return result;\n\n      function applyRequestMiddlewares( requestInfo ) {\n         const combine = ( requestInfoPromise, nextMiddleware ) =>\n            'request' in nextMiddleware ?\n               requestInfoPromise.then( requestInfo => nextMiddleware.request( requestInfo ) ) :\n               requestInfoPromise;\n         return globalOptions.middlewares\n            .reduce( combine, Promise.resolve( requestInfo ) );\n      }\n\n      function applyResponseMiddlewares( responseInfo ) {\n         const combine = ( responsePromise, nextMiddleware ) =>\n            'response' in nextMiddleware ?\n               responsePromise.then( responseInfo => nextMiddleware.response( responseInfo ) ) :\n               responsePromise;\n         return [ ...globalOptions.middlewares ].reverse()\n            .reduce( combine, Promise.resolve( responseInfo ) );\n      }\n   }\n\n   ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n   function createInit( localInit, method, headers, bodyObject ) {\n      const config = {\n         ...globalOptions.fetchInit,\n         ...localInit,\n         method,\n         headers\n      };\n      delete config.body;\n      if( bodyObject !== undefined ) {\n         config.body = JSON.stringify( bodyObject );\n      }\n      return config;\n   }\n\n   ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n   function createHeaders( method, localHeaders ) {\n      let defaultHeaders = DEFAULT_UNSAFE_HEADERS;\n      if( method === 'GET' ) {\n         defaultHeaders = DEFAULT_SAFE_HEADERS;\n      }\n      else if( method === 'PATCH' ) {\n         defaultHeaders = DEFAULT_PATCH_HEADERS;\n      }\n      return { ...defaultHeaders, ...globalOptions.headers, ...localHeaders };\n   }\n\n   ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n   return api;\n\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Returns a copy of the given HAL representation with all HAL media type specific properties removed.\n * Currently these are `_links` and `_embedded`.\n *\n * @param {Object} halRepresentation\n *    the representation to clean up\n *\n * @return {Object}\n *    the copy without HAL media type keys\n */\nexport function removeHalKeys( halRepresentation ) {\n   if( halRepresentation != null && typeof halRepresentation === 'object' ) {\n      const copy = JSON.parse( JSON.stringify( halRepresentation ) );\n      delete copy._embedded;\n      delete copy._links;\n      return copy;\n   }\n   return halRepresentation;\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Returns `true` if the given relation exists as link or is embedded.\n *\n * @param {Object} halRepresentation\n *    HAL representation to check for the relation\n * @param {String} relation\n *    name of the relation to find\n *\n * @return {Boolean} `true` if `relation` exists in the representation\n */\nexport function canFollow( halRepresentation, relation ) {\n   return !!( ( halRepresentation._links && relation in halRepresentation._links ) ||\n      ( halRepresentation._embedded && relation in halRepresentation._embedded ) );\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Returns the first value of href for the requested relation. Search for the relation starts under\n * `_links` and continues in `_embedded`, if not found in `_links`. If not found at all, `null` is\n * returned.\n * If the relation is found and yields only a single value, that value's `href` attribute value is\n * returned. If the relation yields a list, the `href` attribute value of the first entry is returned.\n *\n * @param {Object} halRepresentation\n *    the representation to search for the relation\n * @param {String} relation\n *    the relation to get a `href` attribute value from\n *\n * @return {String} the `href` attribute value if available, `null` otherwise\n */\nexport function firstRelationHref( halRepresentation, relation ) {\n   if( halRepresentation._links && relation in halRepresentation._links ) {\n      const linkOrLinks = halRepresentation._links[ relation ];\n      return Array.isArray( linkOrLinks ) ? linkOrLinks[ 0 ].href : linkOrLinks.href;\n   }\n\n   return path( halRepresentation, `_embedded.${relation}._links.self.href`, null );\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Returns the first value of href for the *self* relation. The same as for {@link #firstRelationHref} holds,\n * but normally a *self* relation should always be present for a RESTful webservice.\n *\n * @param {Object} halRepresentation\n *    the representation to search for the *self* relation\n *\n * @return {String} the `href` attribute value if available, `null` otherwise\n */\nexport function selfLink( halRepresentation ) {\n   return firstRelationHref( halRepresentation, 'self' );\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nfunction path( obj, thePath, optionalDefault = undefined ) {\n   const pathArr = thePath.split( '.' );\n   let node = obj;\n   let key = pathArr.shift();\n\n   while( key ) {\n      if( node && typeof node === 'object' && node.hasOwnProperty( key ) ) {\n         node = node[ key ];\n         key = pathArr.shift();\n      }\n      else {\n         return optionalDefault;\n      }\n   }\n\n   return node;\n}\n"]}